// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;

/// FFI bindings for unistd system calls (open, close, read, write)
class Unistd {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Unistd(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Unistd.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  int fcntl(int __fd, int __cmd) {
    return _fcntl(__fd, __cmd);
  }

  late final _fcntlPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('fcntl');
  late final _fcntl = _fcntlPtr.asFunction<int Function(int, int)>();

  int open(ffi.Pointer<ffi.Char> __file, int __oflag) {
    return _open(__file, __oflag);
  }

  late final _openPtr =
      _lookup<
        ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>
      >('open');
  late final _open = _openPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Close the file descriptor FD.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int close(int __fd) {
    return _close(__fd);
  }

  late final _closePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
    'close',
  );
  late final _close = _closePtr.asFunction<int Function(int)>();

  /// Read NBYTES into BUF from FD.  Return the
  /// number read, -1 for errors or 0 for EOF.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int read(int __fd, ffi.Pointer<ffi.Void> __buf, int __nbytes) {
    return _read(__fd, __buf, __nbytes);
  }

  late final _readPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Long Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)
        >
      >('read');
  late final _read = _readPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Write N bytes of BUF to FD.  Return the number written, or -1.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int write(int __fd, ffi.Pointer<ffi.Void> __buf, int __n) {
    return _write(__fd, __buf, __n);
  }

  late final _writePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Long Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)
        >
      >('write');
  late final _write = _writePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();
}

const int F_GETLK64 = 5;

const int F_SETLK64 = 6;

const int F_SETLKW64 = 7;

const int O_ACCMODE = 3;

const int O_RDONLY = 0;

const int O_WRONLY = 1;

const int O_RDWR = 2;

const int O_CREAT = 64;

const int O_EXCL = 128;

const int O_NOCTTY = 256;

const int O_TRUNC = 512;

const int O_APPEND = 1024;

const int O_NONBLOCK = 2048;

const int O_NDELAY = 2048;

const int O_SYNC = 1052672;

const int O_FSYNC = 1052672;

const int O_ASYNC = 8192;

const int F_GETLK = 5;

const int F_SETLK = 6;

const int F_SETLKW = 7;

const int O_DIRECTORY = 16384;

const int O_NOFOLLOW = 32768;

const int O_CLOEXEC = 524288;

const int O_DSYNC = 4096;

const int O_RSYNC = 1052672;

const int F_DUPFD = 0;

const int F_GETFD = 1;

const int F_SETFD = 2;

const int F_GETFL = 3;

const int F_SETFL = 4;

const int F_SETOWN = 8;

const int F_GETOWN = 9;

const int F_DUPFD_CLOEXEC = 1030;

const int F_RDLCK = 0;

const int F_WRLCK = 1;

const int F_UNLCK = 2;

const int F_EXLCK = 4;

const int F_SHLCK = 8;

const int F_OK = 0;

const int F_ULOCK = 0;

const int F_LOCK = 1;

const int F_TLOCK = 2;

const int F_TEST = 3;
